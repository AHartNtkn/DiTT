module Std.Adjunction where

postulate
  C : Cat
  D : Cat
  F : (x : C) → D
  G : (y : D) → C
  // The adjunction hom-isomorphism: (F a →[D] b) <→ (a →[C] G b)
  adjoint_forward : ∫ (a : C). ∫ (b : D). ((F a →[D] b) → (a →[C] G b))
  adjoint_backward : ∫ (a : C). ∫ (b : D). ((a →[C] G b) → (F a →[D] b))

// Bundled adjunction iso type: both directions packaged as a product, natural in a and b.
adjunction_iso : Prop =
  ∫ (a : C). ∫ (b : D). (((F a →[D] b) → (a →[C] G b)) × ((a →[C] G b) → (F a →[D] b)))

// Unit of the adjunction: eta_a : a →[C] G (F a)
// Derived by instantiating adjoint_forward at b = F a with refl (F a).
unit (a : C) : a →[C] G (F a) =
  adjoint_forward a (F a) (refl (F a))

// Counit of the adjunction: epsilon_b : F (G b) →[D] b
// Derived by instantiating adjoint_backward at a = G b with refl (G b).
counit (b : D) : F (G b) →[D] b =
  adjoint_backward (G b) b (refl (G b))

// Functorial action of F on morphisms.
diag_map_F (z : C) : F z →[D] F z = refl (F z)

map_F (a : C^) (b : C) (f : a →[C] b) : F a →[D] F b = J diag_map_F [f]

// Functorial action of G on morphisms.
diag_map_G (z : D) : G z →[C] G z = refl (G z)

map_G (a : D^) (b : D) (f : a →[D] b) : G a →[C] G b = J diag_map_G [f]

// Composition in D.
diag_comp_D (c : D) (z : D) : (z →[D] c) → (z →[D] c) = λk. k

compose_D (a : D^) (b : D) (c : D) (f : a →[D] b) (g : b →[D] c) : a →[D] c =
  (J (diag_comp_D c) [f]) g

// Composition in C.
diag_comp_C (c : C) (z : C) : (z →[C] c) → (z →[C] c) = λk. k

compose_C (a : C^) (b : C) (c : C) (f : a →[C] b) (g : b →[C] c) : a →[C] c =
  (J (diag_comp_C c) [f]) g

// Triangle identity 1 composite: epsilon_{Fx} . F(eta_x) : Fx →[D] Fx
// By the triangle identity, this equals refl (F x) = id_{Fx}.
triangle1_composite (x : C) : F x →[D] F x =
  compose_D (F x) (F (G (F x))) (F x) (map_F x (G (F x)) (unit x)) (counit (F x))

// Triangle identity 2 composite: G(epsilon_y) . eta_{Gy} : Gy →[C] Gy
// By the triangle identity, this equals refl (G y) = id_{Gy}.
triangle2_composite (y : D) : G y →[C] G y =
  compose_C (G y) (G (F (G y))) (G y) (unit (G y)) (map_G (F (G y)) y (counit y))
